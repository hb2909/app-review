# -*- coding: utf-8 -*-
"""AppScraper_ReplyAutomation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WGBo52VqLf4nceeQpsmn140v5wmYI4oD
"""

#this model is proposed to scrape data from a specific app's reviews from the play store, and based on a set of predetermined answers, automate replies to reviews.

#google_play_scraper used to scrape reviews from play store with python
!pip install google-play-scraper

from google_play_scraper import app, reviews

app_details = app(
    'com.pbb.pbenterprise',
    lang='en',
)

review_list, _ = reviews(
    'com.pbb.pbenterprise',
    lang='en',
)

review_text = [review['content'] for review in review_list]
review_rating = [review['score'] for review in review_list]

!pip install transformers

from transformers import pipeline

sentiment_analyzer= pipeline('sentiment-analysis')

#sentiments = [sentiment_analyzer(review)[0] for review in review_list]

review_texts = [review['content'] for review in review_list]

# Step 2: Load the sentiment analysis model using default model Hugging Face use for sentiment analysis
sentiment_analyzer = pipeline('sentiment-analysis', model="distilbert-base-uncased-finetuned-sst-2-english")

# Step 3: Analyze sentiment of all reviews in batch
sentiments = sentiment_analyzer(review_texts)

# Step 4: Output the results (review + sentiment)
for review, sentiment in zip(review_texts, sentiments):
    print(f"Review: {review}\nSentiment: {sentiment['label']}, Confidence: {sentiment['score']:.2f}\n")

def get_predefined_reply(sentiment_label):
    if sentiment_label == 'POSITIVE':
        return "Thank you for your feedback. We're glad you enjoyed the app."
    elif sentiment_label == 'NEGATIVE':
        return "We're sorry to hear about your experience. Could you please provide more details to so we can assist you further?"
    else:
        return "Thank you for your review. We're constantly improving our app, and your feedback helps make the app better."

"""Visualizing the nature of (sentiment type) of the reviews in this app."""

sentiment_counts = {
    'POSITIVE': 0,
    'NEGATIVE': 0
}

for sentiment in sentiments:
  label=sentiment['label']
  sentiment_counts[label] +=1

import matplotlib.pyplot as plt
import seaborn as sns

#bar chart

plt.figure(figsize=(6, 4))
sns.barplot(x=list(sentiment_counts.keys()), y=list(sentiment_counts.values()))
plt.title('Review Nature Distribution')
plt.xlabel('Review Nature')
plt.ylabel('Number of Reviews')
plt.show()

import numpy as np
from scipy import stats
import pandas as pd

sentiment_scores = [sentiment['score'] for sentiment in sentiments]

data = pd.DataFrame({
    'review': review_list,
    'rating': review_rating,
    'sentiment_score': sentiment_scores
})

Q1_rating = data['rating'].quantile(0.25)
Q3_rating = data['rating'].quantile(0.75)
IQR_rating = Q3_rating - Q1_rating

rating_outliers = data[(data['rating'] < Q1_rating - 1.5 * IQR_rating) | (data['rating'] > Q3_rating + 1.5 * IQR_rating)]

data['z_score_sentiment'] = np.abs(stats.zscore(data['sentiment_score']))

sentiment_outliers = data[data['z_score_sentiment'] > 3]

plt.figure(figsize=(8, 4))
sns.boxplot(data=data, x='rating')
plt.title('Boxplot for Ratings')
plt.show()

plt.figure(figsize=(8, 4))
sns.boxplot(data=data, x='sentiment_score')
plt.title('Boxplot for Sentiment Scores')
plt.show()

print("Rating Outliers:")
print(rating_outliers)

print("\nSentiment Score Outliers:")
print(sentiment_outliers)

from transformers import GPT2LMHeadModel, GPT2Tokenizer

# Load pre-trained GPT-2 model and tokenizer
model = GPT2LMHeadModel.from_pretrained('gpt2')
tokenizer = GPT2Tokenizer.from_pretrained('gpt2')

def generate_reply(review_text):
    inputs = tokenizer.encode("Reply to: " + review_text, return_tensors="pt")
    outputs = model.generate(inputs, max_length=100, do_sample=True)
    reply = tokenizer.decode(outputs[0], skip_special_tokens=True)
    return reply

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.decomposition import LatentDirichletAllocation

# Extract features from the reviews
count_vectorizer = CountVectorizer(stop_words='english')
term_matrix = count_vectorizer.fit_transform(review_texts)

# Apply LDA to discover topics in the reviews
lda_model = LatentDirichletAllocation(n_components=5, random_state=42)
lda_model.fit(term_matrix)

# Extract and display the topics
topics = lda_model.components_

"""Testing the automated reply with random review."""

#Test 1
test_review = "I can make transactions easily."
response = test_reply_model(test_review)
print(f"Review: {test_review}\nReply: {response}\n")

#Test 2
test_review_2 = "This app keeps crashing. Very annoying"
response_2 = test_reply_model(test_review_2)
print(f"Review: {test_review_2}\nReply: {response_2}\n")

